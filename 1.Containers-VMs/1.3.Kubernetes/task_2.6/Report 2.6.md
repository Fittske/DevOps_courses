# Задача 2.6: Знакомство с Kubernetes и Minikube

## Подготовка

Подготовим файл манифеста для нашего будущего пода:

1. Создадим и отредактируем манифест:  
`nano my-pod.yaml`
2. Указываем версию api - для пода используем v1 (подробнее тут - https://kubernetes.io/ru/docs/concepts/overview/kubernetes-api/):  
`apiVersion: v1`
3. Указываем тип объекта - в нашем случае pod:  
`kind: Pod`
4. Начинаем заполнять метаданные. Поля содержать информацию об объекте, например имя, метки и т.д.:  
    ```
    metadata:
      name: webapp
    ```
5. Далее заполним раздел спецификации. Данный раздел содержит дополнительную информацию, которая зависит от объекта, который мы собираем запускать.:  
`spec:`
6. Так как мы создаем кластер с контейнером, то добавляем соответствующее свойство и заполняем только один элемент, так как планируем запустить только один контейнер в кластере:  
`containers:`
7. Указываем имя контейнера:  
`- name: webapp`
8. Указываем образ контейнера. Для примера, возьмем готовое простое веб-приложение:  
`image: karthequian/helloworld:latest`
9. Также укажем порты:  
    ```
    ports:
    - containerPort: 80
    ```

Общий вид нашего манифеста для пода:  
```
apiVersion: v1
kind: Pod
metadata:
  name: webapp
spec:
  containers:
  - name: webapp
    image: karthequian/helloworld:latest
    ports:
    - containerPort: 80

```

## Запуск мини-кластера

1. Запускаем кластер kubernetes с помощью minikube, с docker в качестве драйвера:  
`minikube start --force --driver=docker`
![img_44.png](img_44.png)
2. Проверяем состояние кластера с помощью kubectl:  
`kubectl cluster-info`

3. Создаем под, используя подготовленный манифест my-pod.yaml:  
`kubectl create -f my-pod.yaml`
![img_46.png](img_46.png)
4. Проверяем состояние пода:  
`kubectl get pods`
![img_47.png](img_47.png)
5. Проверяем состояние сервиса:  
`kubectl get service`
![img_48.png](img_48.png)
6. Получим более подробную информацию о созданном поде:  
`kubectl describe pod webapp`
![img_49.png](img_49.png)
7. Запустим отладку внутри контейнера пода:  
`kubectl exec -it webapp -- bin/bash`
![img_50.png](img_50.png)
8. Подключимся к среде minikube:  
`minikube ssh`
9. Проверим содержимое нашей веб-страницы. Для этого воспользуем утилитой curl с указанием ip-адреса нашего пода:  
`curl 10.244.0.14`
![img_51.png](img_51.png)
10. Далее выйдем из среды minikube и проверим журналы пода:  
`kubectl logs webapp`
![img_52.png](img_52.png)
11. Остановим и удалим под, после чего убедимся что все прошло успешно:  
`kubectl delete pod webapp`  
`kubectl get pods`
![img_53.png](img_53.png)
12. Остановим и удалим сервис, и также убедимся в успехе:   
`kubectl delete service kubernetes`  
`kubectl get services`
![img_54.png](img_54.png)
13. Напоследок, останавливаем наш мини-кластер:  
`minikube stop`
![img_55.png](img_55.png)

## Выводы

Minikube - отличный инструмент, для того, чтобы познакомиться с Kubernetes и применить его возможности на локальной машине. С помощью minikube разработчикам может быть удобно разрабатывать и тестировать приложения, которые в будущем будут запущены на полноценном кластере Kubernetes. С помощью средств Kubernetes в minikube можно относительно легко и быстро задеплоить необходимое веб-приложение.

Также данный инструмент удобен для использования DevOps инженерами, так как позволяет проводить различные эксперименты, тестировать различные конфигурации и оптимизировать развертку приложений.

Сам же Kubernetes позволяет управлять всем проектом единообразно с помощью файлов конфигурации и имеет подробные руководства и документацию.  В случае, когда у вас действительно много контейнизированных приложений, то управлять ими по отдельности довольно трудоемкая задача - и тогда кубер будет одним из хороших решений.   

По итогам выполнения данного задания, можно сделать вывод о том, что k8s позволяет нативно делать довольно много полезных вещей, например вести логи отдельных подов / контейнеров, следить за их работой и состоянием, гибко управлять конфигурацией, запуском и остановкой.



